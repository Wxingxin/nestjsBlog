下面是一套**可直接复制**的 NestJS + TypeORM + MySQL **完整 CRUD 示例**（包含：Entity / DTO / Module / Service / Controller / AppModule / main.ts），并且我把**每个文件都标清路径 + 关键代码注释**。

> 目标：你照着建文件、粘贴代码，就能跑通 `users` 的增删改查。

---

## 0）创建模块（建议用 CLI）

```bash
nest g module users
nest g service users
nest g controller users
```

---

## 1）main.ts（启动入口）

**路径：`src/main.ts`**

```ts
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)

  // ✅ 给前端/接口测试工具用（按需开启）
  app.enableCors()

  await app.listen(3000)
}
bootstrap()
```

---

## 2）AppModule：连接数据库（TypeORM 全局配置）

**路径：`src/app.module.ts`**

```ts
import { Module } from '@nestjs/common'
import { TypeOrmModule } from '@nestjs/typeorm'
import { UsersModule } from './users/users.module'

@Module({
  imports: [
    // ✅ forRoot：全局只配置一次数据库连接
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: '123456',
      database: 'test_db',

      // ✅ autoLoadEntities：模块里 forFeature 注册过的 Entity 会自动加载
      autoLoadEntities: true,

      // ⚠️ 开发环境方便：自动同步表结构；生产必须关掉
      synchronize: true,

      // ✅ 调试 SQL（可选）
      logging: true,
    }),

    UsersModule,
  ],
})
export class AppModule {}
```

---

## 3）User Entity：表结构定义

**路径：`src/users/user.entity.ts`**

```ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm'

/**
 * ✅ Entity = 数据库表
 * @Entity('users') 指定表名为 users
 */
@Entity('users')
export class User {
  /**
   * ✅ 主键，自增
   */
  @PrimaryGeneratedColumn()
  id: number

  /**
   * ✅ 索引：常用查询字段建议加索引
   */
  @Index()
  @Column({ length: 50 })
  username: string

  /**
   * ✅ unique：邮箱唯一
   */
  @Column({ unique: true })
  email: string

  /**
   * ✅ 可选字段：nullable 表示允许为 NULL
   */
  @Column({ nullable: true })
  avatar?: string

  /**
   * ✅ 自动写入创建时间
   */
  @CreateDateColumn()
  createdAt: Date

  /**
   * ✅ 自动写入更新时间
   */
  @UpdateDateColumn()
  updatedAt: Date
}
```

---

## 4）DTO：定义入参结构（Create / Update）

> DTO 用于“约束请求 body 的字段”。先给你最基础版（不引入 class-validator），后面你要我可以升级成带校验的。

### 4.1 CreateUserDto

**路径：`src/users/dto/create-user.dto.ts`**

```ts
/**
 * ✅ 创建用户时允许传入的字段
 * 注意：id / createdAt / updatedAt 不应该由前端传
 */
export class CreateUserDto {
  username: string
  email: string
  avatar?: string
}
```

### 4.2 UpdateUserDto

**路径：`src/users/dto/update-user.dto.ts`**

```ts
/**
 * ✅ 更新：通常是“部分更新”，所以都用可选
 */
export class UpdateUserDto {
  username?: string
  email?: string
  avatar?: string
}
```

---

## 5）UsersModule：注册 Repository

**路径：`src/users/users.module.ts`**

```ts
import { Module } from '@nestjs/common'
import { TypeOrmModule } from '@nestjs/typeorm'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'
import { User } from './user.entity'

@Module({
  imports: [
    /**
     * ✅ forFeature([User])：让 User 的 Repository 在本模块可注入
     */
    TypeOrmModule.forFeature([User]),
  ],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

---

## 6）UsersService：CRUD 核心逻辑（带常见报错处理）

**路径：`src/users/users.service.ts`**

```ts
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { User } from './user.entity'
import { CreateUserDto } from './dto/create-user.dto'
import { UpdateUserDto } from './dto/update-user.dto'

@Injectable()
export class UsersService {
  constructor(
    /**
     * ✅ 注入 User 对应的 Repository（相当于 users 表的操作入口）
     */
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
  ) {}

  /**
   * C - Create
   */
  async create(dto: CreateUserDto) {
    // ✅ 如果你想“创建前先查重”（比如邮箱唯一）
    const existed = await this.userRepo.findOne({ where: { email: dto.email } })
    if (existed) {
      throw new ConflictException('Email 已存在')
    }

    /**
     * ✅ create：把 dto 变成 entity 实例（还没入库）
     * 注意：create 不会写数据库
     */
    const user = this.userRepo.create(dto)

    /**
     * ✅ save：插入/更新（有 id 就更新，没有 id 就插入）
     */
    return this.userRepo.save(user)
  }

  /**
   * R - Read（查全部）
   */
  findAll() {
    /**
     * ✅ find：查询多条
     * 可扩展：分页 / 排序 / 条件
     */
    return this.userRepo.find({
      order: { id: 'DESC' },
    })
  }

  /**
   * R - Read（查单个）
   */
  async findOne(id: number) {
    /**
     * ✅ findOneBy：按条件查一条（更轻量）
     */
    const user = await this.userRepo.findOneBy({ id })
    if (!user) throw new NotFoundException('用户不存在')
    return user
  }

  /**
   * U - Update（局部更新）
   */
  async update(id: number, dto: UpdateUserDto) {
    // ✅ 先确认存在
    const user = await this.userRepo.findOneBy({ id })
    if (!user) throw new NotFoundException('用户不存在')

    /**
     * ✅ merge：把 dto 合并到 entity 上
     */
    const merged = this.userRepo.merge(user, dto)

    /**
     * ✅ save：因为 merged 有 id，所以是更新
     */
    return this.userRepo.save(merged)
  }

  /**
   * D - Delete
   */
  async remove(id: number) {
    // ✅ delete 不会报 “不存在”，所以你如果想要 404，得自己查
    const result = await this.userRepo.delete(id)
    if (result.affected === 0) {
      throw new NotFoundException('用户不存在')
    }
    return { success: true }
  }
}
```

---

## 7）UsersController：暴露 REST API（完整路由）

**路径：`src/users/users.controller.ts`**

```ts
import { Controller, Get, Post, Patch, Delete, Param, Body } from '@nestjs/common'
import { UsersService } from './users.service'
import { CreateUserDto } from './dto/create-user.dto'
import { UpdateUserDto } from './dto/update-user.dto'

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  /**
   * POST /users
   * 创建用户
   */
  @Post()
  create(@Body() dto: CreateUserDto) {
    return this.usersService.create(dto)
  }

  /**
   * GET /users
   * 查询全部用户
   */
  @Get()
  findAll() {
    return this.usersService.findAll()
  }

  /**
   * GET /users/:id
   * 查询单个用户
   */
  @Get(':id')
  findOne(@Param('id') id: string) {
    // ✅ Param 默认是 string，这里转 number
    return this.usersService.findOne(Number(id))
  }

  /**
   * PATCH /users/:id
   * 更新用户（部分字段）
   */
  @Patch(':id')
  update(@Param('id') id: string, @Body() dto: UpdateUserDto) {
    return this.usersService.update(Number(id), dto)
  }

  /**
   * DELETE /users/:id
   * 删除用户
   */
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(Number(id))
  }
}
```

---

## 8）接口测试示例（你用 Postman / Apifox 都行）

### 创建用户

```http
POST http://localhost:3000/users
Content-Type: application/json

{
  "username": "wjx",
  "email": "wjx@test.com",
  "avatar": "https://xx.com/a.png"
}
```

### 查全部

```http
GET http://localhost:3000/users
```

### 查单个

```http
GET http://localhost:3000/users/1
```

### 更新

```http
PATCH http://localhost:3000/users/1
Content-Type: application/json

{
  "username": "wjx-updated"
}
```

### 删除

```http
DELETE http://localhost:3000/users/1
```

---

## 下一步（建议你马上做的升级点）

如果你想更“企业级”，我建议你下一步升级：

1. ✅ DTO 加 `class-validator` 校验（必备）
2. ✅ 分页查询 `GET /users?page=1&pageSize=10`
3. ✅ 模糊搜索 `username LIKE`
4. ✅ 统一响应结构（拦截器/过滤器）
5. ✅ 迁移 migration（替代 synchronize）

你回复我一句：**“给我加上 DTO 校验 + 分页 + 模糊搜索”**
我就基于这套代码直接升级，并把新增文件也全部贴出来（同样带注释）。
