下面这份是**给 NestJS 小白看的「模块 & 依赖注入类装饰器」终极入门版**。
我会 **只讲你现在必须懂的**，不提前把你吓到，同时保证你以后看高级项目不懵。

> 你只要记住一句话：
> **NestJS = 模块 + 依赖注入（DI）**

---

# 🧩 一、模块相关装饰器（`@Module`）

> **模块 = NestJS 项目的“文件夹级组织单位”**

---

## 1️⃣ `@Module()` —— 项目骨架核心

👉 **写在：`xxx.module.ts` 的 class 上**

```ts
@Module({
  imports: [],
  controllers: [],
  providers: [],
  exports: [],
})
export class UserModule {}
```

---

## `@Module` 四个核心属性（必背）

### ① `controllers`

👉 **放 Controller（接请求）**

```ts
controllers: [UserController]
```

📌 知识点：

* Controller **只能写在模块里**
* 不在 `controllers` 里 = 路由失效

---

### ② `providers`

👉 **放 Service / Provider（业务逻辑）**

```ts
providers: [UserService]
```

📌 知识点：

* **只有在 providers 里的类才能被注入**
* 绝大多数 `@Injectable()` 类都放这里

---

### ③ `imports`

👉 **引入其他模块**

```ts
imports: [AuthModule]
```

📌 知识点（非常重要）：

* 模块之间**不能直接互相用**
* 必须 **先 import 模块，再用它 export 的 provider**

---

### ④ `exports`

👉 **向外“暴露” provider**

```ts
exports: [UserService]
```

📌 知识点：

* 不 export = 外部模块注入不到
* **模块是“隔离边界”**

---

## 🧠 模块依赖关系示意

```txt
UserModule
 ├─ providers: UserService
 └─ exports:  UserService
          ↓
AuthModule imports UserModule
```

---

# 🧩 二、依赖注入类装饰器（`@Injectable`）

> **DI 的一句话解释：**
> 👉 “我不 new，你帮我给”

---

## 2️⃣ `@Injectable()` —— 让类可被注入

👉 **写在：Service / Provider 的 class 上**

```ts
@Injectable()
export class UserService {}
```

📌 如果没有 `@Injectable()`：

* ❌ Nest 无法管理这个类
* ❌ constructor 注入会报错

---

## 依赖注入的基本写法（必会）

```ts
@Injectable()
export class UserService {
  findAll() {
    return []
  }
}
```

```ts
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  findAll() {
    return this.userService.findAll()
  }
}
```

📌 **重点理解**

* `UserController` **没有 new UserService**
* Nest 自动创建并注入实例

---

## 🧠 Nest 为什么要 DI？

| 问题   | 没 DI | 有 DI |
| ---- | ---- | ---- |
| 耦合度  | 高    | 低    |
| 可测试性 | 差    | 极好   |
| 替换实现 | 困难   | 非常简单 |

---

# 🧩 三、Controller 类装饰器（`@Controller`）

---

## 3️⃣ `@Controller()` —— HTTP 入口

👉 **写在：Controller 类上**

```ts
@Controller('users')
export class UserController {}
```

📌 知识点：

* `'users'` 是路由前缀
* 不写路径 = 根路径 `/`

---

## Controller + Module 必须同时存在

```ts
@Module({
  controllers: [UserController],
})
export class UserModule {}
```

❌ 没写进 module = 访问不到接口

---

# 🧩 四、Provider 的本质（小白最容易迷糊）

---

## Provider 是什么？

> **Provider = 可以被注入的东西**

默认 Provider：

```ts
@Injectable()
export class UserService {}
```

等价于：

```ts
providers: [
  {
    provide: UserService,
    useClass: UserService,
  },
]
```

📌 **先别死记，知道“本质是映射关系”即可**

---

# 🧩 五、模块 + DI 的完整最小示例（必看）

```
src/
├─ user/
│  ├─ user.module.ts
│  ├─ user.controller.ts
│  └─ user.service.ts
```

### `user.service.ts`

```ts
@Injectable()
export class UserService {
  getUsers() {
    return ['wjx']
  }
}
```

### `user.controller.ts`

```ts
@Controller('users')
export class UserController {
  constructor(private userService: UserService) {}

  @Get()
  findAll() {
    return this.userService.getUsers()
  }
}
```

### `user.module.ts`

```ts
@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

---

# 🧩 六、小白最常犯的 5 个错误 ❌

### ❌ 1. Service 没加 `@Injectable`

👉 Nest 无法注入

---

### ❌ 2. Service 没写进 `providers`

👉 constructor 报错

---

### ❌ 3. Controller 没写进 `controllers`

👉 路由 404

---

### ❌ 4. 模块没 export 却在别的模块用

👉 Nest 找不到 provider

---

### ❌ 5. 自己 `new UserService()`

👉 直接破坏 DI 体系（严禁）

---

# 🧠 一句话总结（一定要背）

> * **Module**：组织代码 + 隔离边界
> * **Controller**：接收请求
> * **Service（Provider）**：业务逻辑
> * **Injectable**：让类进入 DI 容器

---

## 🚀 下一步学习建议（强烈）

你现在已经到 **NestJS 真正入门的临界点**，下一步我建议：

1️⃣ **模块之间如何通信（imports + exports 深度图解）**
2️⃣ **依赖注入底层原理（为什么 constructor 能自动拿到实例）**
3️⃣ **Guard / Pipe / Interceptor 是怎么插入请求流程的**

你选一个，我继续带你。
