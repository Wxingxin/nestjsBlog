下面这是一份 **「给 NestJS 小白看的 · 路由装饰器使用大全 + 必懂知识点」**。
目标只有一个：**你看到 Controller 里的路由装饰器，不再懵，知道“它在干嘛、该什么时候用”**。

> 在 NestJS 中：
> **路由装饰器 = 把 HTTP 请求映射到方法**

---

# 🧠 一句话先建立直觉

```ts
@Get('list')
findAll() {}
```

这句话的真实含义是：

> **当客户端 GET 请求命中某个 URL 时，执行这个方法**

---

# 🧩 一、路由装饰器是写在哪里的？

### 只写在 2 个地方：

1️⃣ **`@Controller()` 上（定义路由前缀）**
2️⃣ **Controller 的方法上（定义 HTTP 行为）**

---

# 🧩 二、`@Controller()` —— 路由前缀（必懂）

👉 **写在：Controller 类上**
 
```ts
@Controller('users')
export class UserController {}
```

### 📌 它的作用

* 给当前 Controller **统一加一个 URL 前缀**
* 所有方法路由都在它下面

```txt
/users/xxx
```

### ❗ 不写路径会怎样？

```ts
@Controller()
```

👉 路由从根路径 `/` 开始（不推荐新手这样写）

---

# 🧩 三、HTTP 方法路由装饰器（核心）

👉 **写在：Controller 的方法上**

---

## 1️⃣ `@Get()` —— 查询数据（最常用）

```ts
@Get()
findAll() {}
```

```txt
GET /users
```

---

## 2️⃣ `@Post()` —— 新增数据

```ts
@Post()
create() {}
```

```txt
POST /users
```

---

## 3️⃣ `@Put()` —— 全量更新

```ts
@Put(':id')
update() {}
```

```txt
PUT /users/1
```

---

## 4️⃣ `@Patch()` —— 局部更新（推荐）

```ts
@Patch(':id')
patch() {}
```

📌 真实项目中：

* **更新通常用 `PATCH`**
* `PUT` 很少用

---

## 5️⃣ `@Delete()` —— 删除

```ts
@Delete(':id')
remove() {}
```

---

## 📌 HTTP 方法与业务语义对照表（必背）

| 装饰器       | HTTP   | 语义 |
| --------- | ------ | -- |
| `@Get`    | GET    | 查询 |
| `@Post`   | POST   | 新增 |
| `@Patch`  | PATCH  | 修改 |
| `@Put`    | PUT    | 覆盖 |
| `@Delete` | DELETE | 删除 |

---

# 🧩 四、路由路径写法大全（新手必看）

---

## 6️⃣ 空路径（最常见）

```ts
@Get()
```

👉 访问的是 **Controller 前缀本身**

```txt
/users
```

---

## 7️⃣ 子路径

```ts
@Get('list')
```

```txt
/users/list
```

---

## 8️⃣ 动态路由参数（非常重要）

```ts
@Get(':id')
findOne(@Param('id') id: string) {}
```

```txt
/users/123
```

📌 知识点：

* `:id` 是占位符
* 必须配合 `@Param()` 使用

---

## 9️⃣ 多级路径

```ts
@Get(':id/posts')
```

```txt
/users/1/posts
```

---

# 🧩 五、路由参数相关装饰器（配合使用）

虽然你问的是**路由装饰器**，但这些是**必须一起学的**👇

---

## 10️⃣ `@Param()` —— 路径参数

```ts
@Get(':id')
find(@Param('id') id: string) {}
```

---

## 11️⃣ `@Query()` —— 查询参数

```ts
@Get()
find(@Query('page') page: number) {}
```

```txt
/users?page=1
```

---

## 12️⃣ `@Body()` —— 请求体（POST / PATCH）

```ts
@Post()
create(@Body() dto: CreateUserDto) {}
```

---

# 🧩 六、路由装饰器的组合效果（你一定要会）

---

## 13️⃣ Controller + 方法 = 完整 URL

```ts
@Controller('users')
export class UserController {
  @Get(':id')
  findOne() {}
}
```

👉 实际路由是：

```txt
GET /users/:id
```

---

## 14️⃣ 一个 Controller 管理一类资源（REST 思想）

```ts
@Controller('users')
```

👉 只负责：

* 用户相关路由
* 不写别的业务

📌 **这是 NestJS 项目结构清晰的核心原因**

---

# 🧩 七、路由装饰器常见错误（新手 100% 会踩）

---

### ❌ 1. 方法写了 `@Get()`，但 Controller 没注册到 Module

👉 结果：404

---

### ❌ 2. 路由参数写了 `:id`，却没用 `@Param`

👉 结果：拿不到值

---

### ❌ 3. 在 Service 里写路由装饰器

👉 ❌ **路由只属于 Controller**

---

### ❌ 4. 所有接口都写在一个 Controller

👉 后期必炸（维护地狱）

---

# 🧠 八、路由装饰器的“工程级理解”

> **Controller = 路由入口层，不写业务逻辑**

```txt
HTTP 请求
 ↓
路由装饰器匹配
 ↓
Controller（薄）
 ↓
Service（厚）
```

---

# 🧠 一句话终极总结（请记住）

> * `@Controller`：定义路由前缀
> * `@Get / @Post / ...`：定义 HTTP 行为
> * 路由装饰器 **只写在 Controller**
> * 一个 Controller 管理一类资源

---

## 🚀 下一步我强烈建议你学这个（非常关键）

现在你已经会“接请求”了，下一步应该学👇

1️⃣ **请求参数装饰器（`@Param / @Query / @Body` 深度）**
2️⃣ **DTO + 校验（避免脏数据进入系统）**
3️⃣ **RESTful API 设计规范（面试必考）**

你选一个，我继续用**小白能懂 + 实战写法**带你。
