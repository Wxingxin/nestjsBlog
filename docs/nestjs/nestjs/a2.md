下面这份内容是**专门给 NestJS 小白看的「依赖注入（DI）类装饰器使用大全 + 必懂知识点」**。
目标只有一个：**你能看懂、能写、不会再被 constructor 注入吓到**。

我会从 **“你每天在写什么” → “Nest 在背后帮你干了什么”** 这个顺序来讲。

---

# 🧠 一句话先建立正确认知

> **在 NestJS 中：
> 你几乎“不 new 对象”，而是“声明依赖关系”**

```ts
constructor(private userService: UserService) {}
```

这行代码的含义不是：

> ❌ 创建对象

而是：

> ✅ **告诉 Nest：我需要一个 UserService，请你给我**

---

# 🧩 一、什么是「依赖注入类装饰器」？

👉 **只做一件事：让一个类可以被 Nest 的 DI 容器管理**

---

## 1️⃣ `@Injectable()` —— 99% 情况你只用它

### ✅ 最常见写法

```ts
@Injectable()
export class UserService {}
```

### 📌 它解决什么问题？

* 让 Nest **知道这个类可以被创建**
* 让这个类 **可以被注入到别的类**

### ❌ 没有它会怎样？

```ts
export class UserService {}
```

```ts
constructor(private userService: UserService) {}
// ❌ Nest 无法解析依赖
```

📌 **记住一句话**：

> **能被注入的类，必须 `@Injectable()`**

---

# 🧩 二、依赖注入最基础的使用（你每天都在写）

## 2️⃣ constructor 注入（标准写法）

```ts
@Injectable()
export class UserService {
  findAll() {
    return ['wjx']
  }
}
```

```ts
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  findAll() {
    return this.userService.findAll()
  }
}
```

### 📌 背后的 DI 逻辑

```txt
UserController 需要 UserService
↓
Nest 查找 providers
↓
创建 UserService 实例
↓
注入到 constructor
```

👉 **你不负责创建对象，Nest 负责**

---

# 🧩 三、Provider 到底是什么？（小白必懂）

> **Provider = 可以被注入的“东西”**

---

## 3️⃣ 默认 Provider 的真实样子（理解即可）

```ts
providers: [UserService]
```

本质等价于：

```ts
providers: [
  {
    provide: UserService,
    useClass: UserService,
  },
]
```

📌 **关键点**

* `provide`：注入 token
* `useClass`：实际创建哪个类

---

# 🧩 四、依赖注入的 4 种常见写法（重点）

---

## 4️⃣ 写法一：Class Provider（最常用）

```ts
providers: [UserService]
```

```ts
constructor(private userService: UserService) {}
```

✅ **新手 100% 用这个**

---

## 5️⃣ 写法二：Value Provider（配置 / 常量）

```ts
providers: [
  {
    provide: 'APP_NAME',
    useValue: 'nest-demo',
  },
]
```

```ts
constructor(@Inject('APP_NAME') appName: string) {}
```

📌 使用场景：

* 常量
* 配置
* 第三方实例

---

## 6️⃣ 写法三：Factory Provider（动态创建）

```ts
providers: [
  {
    provide: 'CONFIG',
    useFactory: () => {
      return { env: 'dev' }
    },
  },
]
```

📌 使用场景：

* 依赖环境变量
* 启动时计算

---

## 7️⃣ 写法四：Class 替换（高级 / 测试）

```ts
providers: [
  {
    provide: UserService,
    useClass: MockUserService,
  },
]
```

📌 使用场景：

* 单元测试
* mock 服务

---

# 🧩 五、`@Inject()` 什么时候才需要？

### ❌ 不需要的情况（90%）

```ts
constructor(private userService: UserService) {}
```

### ✅ 必须用的情况

```ts
constructor(@Inject('CONFIG') config: any) {}
```

📌 规则：

* **类 → 不用 `@Inject`**
* **字符串 / Symbol → 必须 `@Inject`**

---

# 🧩 六、依赖注入的作用域（了解即可）

```ts
@Injectable({ scope: Scope.DEFAULT })
```

| Scope     | 含义       |
| --------- | -------- |
| DEFAULT   | 单例（默认）   |
| REQUEST   | 每个请求一个实例 |
| TRANSIENT | 每次注入新实例  |

📌 新手阶段 **只用默认即可**

---

# 🧩 七、小白最常犯的 6 个错误 ❌

1️⃣ Service 忘记 `@Injectable()`
2️⃣ Service 没写进 `providers`
3️⃣ 模块没 export 就跨模块注入
4️⃣ 自己 `new Service()`
5️⃣ 用字符串 token 却没 `@Inject()`
6️⃣ 在 Controller 写业务逻辑（该放 Service）

---

# 🧠 一句话终极总结（请背下来）

> * **`@Injectable()`：声明“我可以被注入”**
> * **constructor 注入：声明“我需要什么”**
> * **Module providers：声明“我能提供什么”**
> * **Nest 负责创建对象，你只负责用**

---

## 🚀 下一步我强烈建议你学这个（承上启下）

你现在已经真正理解 DI 了，下一步非常关键👇

1️⃣ **模块之间如何共享 provider（imports / exports 深度）**
2️⃣ **为什么 constructor 注入不需要 new（DI 底层原理图解）**
3️⃣ **真实项目中 Service / Repository 如何拆分**

你选一个，我继续用「小白能懂 + 项目级写法」给你讲。
