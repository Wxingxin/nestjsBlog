下面这是一份 **「给 NestJS 小白看的 · 请求参数装饰器使用大全 + 必懂知识点」**。
目标很明确：**你看到 `@Param / @Query / @Body` 等，不再靠猜，知道“从哪来、什么时候用、怎么用才规范”**。

> 在 NestJS 中：
> **请求参数装饰器 = 从 HTTP 请求里“精准拆数据”**

---

# 🧠 一句话先建立直觉

```ts
@Get(':id')
find(@Param('id') id: string) {}
```

真正发生的是：

> **Nest 帮你从 request 里把 `id` 拿出来，再传给方法参数**

你不需要再手写：

```ts
req.params.id
```

---

# 🧩 一、请求参数装饰器写在哪里？

👉 **只能写在 Controller 方法的“参数位置”**

```ts
@Get()
find(@Query('page') page: number) {}
```

📌 **不会写在：**

* class 上 ❌
* 方法上 ❌
* Service 里 ❌

---

# 🧩 二、最核心的 6 个请求参数装饰器（必会）

---

## 1️⃣ `@Param()` —— 路由参数（最常见）

### 使用场景

```txt
/users/123
```

### 基本用法

```ts
@Get(':id')
findOne(@Param('id') id: string) {}
```

### 📌 知识点

* `:id` 来自路由路径
* 默认是 **string**
* 常用于：详情 / 删除 / 更新

---

### 一次拿全部参数

```ts
@Param()
params: Record<string, string>
```

```ts
@Get(':userId/posts/:postId')
find(@Param() params) {
  // { userId: '1', postId: '2' }
}
```

---

## 2️⃣ `@Query()` —— 查询参数

### 使用场景

```txt
/users?page=1&pageSize=10
```

### 基本用法

```ts
@Get()
find(
  @Query('page') page: number,
  @Query('pageSize') pageSize: number,
) {}
```

### 📌 知识点

* 查询参数 **永远是 string**
* 不写校验非常危险（后面用 DTO 解决）

---

### 一次拿全部 query

```ts
@Query() query: any
```

---

## 3️⃣ `@Body()` —— 请求体（非常重要）

### 使用场景

* POST
* PATCH
* PUT

```ts
@Post()
create(@Body() body: any) {}
```

📌 **企业级正确姿势**（必须学）👇

```ts
@Post()
create(@Body() dto: CreateUserDto) {}
```

👉 **请求体 = DTO + 校验**

---

## 4️⃣ `@Headers()` —— 请求头

```ts
@Get()
find(@Headers('authorization') token: string) {}
```

### 📌 使用场景

* JWT
* 自定义 header

⚠️ **真实项目中**：

* 一般不用它
* 交给 Guard 处理更合理

---

## 5️⃣ `@Req()` —— 原始 request（慎用）

```ts
@Get()
find(@Req() req: Request) {}
```

### 📌 知识点（重要）

* 这是 Express / Fastify 原始对象
* 用了就 **跳过 Nest 抽象层**

⚠️ **新手建议**：

> 能不用就不用

---

## 6️⃣ `@Res()` —— 原始 response（不推荐）

```ts
@Get()
find(@Res() res: Response) {
  res.send('ok')
}
```

📌 一旦用了：

* Nest 的自动返回失效
* 拦截器、Filter 可能失效

❌ **新手 & 企业项目不推荐**

---

# 🧩 三、请求参数装饰器 + DTO（非常关键）

> **参数装饰器只负责“取数据”，不负责“判断对错”**

---

## 正确姿势：Query + DTO

```ts
export class QueryUserDto {
  @IsInt()
  @Type(() => Number)
  page: number
}
```

```ts
@Get()
find(@Query() query: QueryUserDto) {}
```

📌 好处：

* 自动校验
* 自动类型转换
* 参数集中管理

---

## 正确姿势：Body + DTO（必学）

```ts
export class CreateUserDto {
  @IsEmail()
  email: string

  @IsString()
  password: string
}
```

```ts
@Post()
create(@Body() dto: CreateUserDto) {}
```

---

# 🧩 四、参数装饰器的组合使用（真实项目）

```ts
@Patch(':id')
update(
  @Param('id') id: string,
  @Body() dto: UpdateUserDto,
) {}
```

📌 非常常见：

* `@Param`：找哪条数据
* `@Body`：更新什么数据

---

# 🧩 五、新手最常踩的 6 个坑 ❌

---

### ❌ 1. 以为 `@Query()` 会自动转 number

👉 不会（除非配 Pipe）

---

### ❌ 2. `@Body()` 用 `any`

👉 失去校验，安全隐患

---

### ❌ 3. 在 Service 里用 `@Param`

👉 ❌ 参数装饰器 **只属于 Controller**

---

### ❌ 4. 混用 `@Req()` + DTO

👉 风格混乱，难维护

---

### ❌ 5. 一个接口拿一堆 `@Query('xxx')`

👉 应该用 DTO 聚合

---

### ❌ 6. Controller 写参数解析逻辑

👉 Controller 要“薄”

---

# 🧠 六、请求参数装饰器的工程级理解

```txt
HTTP Request
 ↓
参数装饰器（取数据）
 ↓
Pipe（校验 / 转换）
 ↓
Controller（转发）
 ↓
Service（业务逻辑）
```

---

# 🧠 一句话终极总结（一定要记住）

> * `@Param`：路径参数
> * `@Query`：查询参数
> * `@Body`：请求体
> * 参数装饰器只做一件事：**取数据**
> * 校验 / 转换交给 DTO + Pipe

---

## 🚀 下一步我强烈建议你学这个（承上启下）

你现在已经能 **“正确接收请求数据”** 了，下一步非常关键👇

1️⃣ **Pipe（ValidationPipe / ParseIntPipe）深度讲解**
2️⃣ **DTO + class-validator 全套路**
3️⃣ **Guard 是如何从 request 里拿 user 的**

你选一个，我继续用 **小白友好 + 项目级写法** 带你。
