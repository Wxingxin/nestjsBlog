下面这是一份 **「给 NestJS 小白看的 · 流程控制装饰器使用大全 + 必懂知识点」**。
你可以把它当成 **NestJS 的“中间件升级版全家桶说明书”**。

> 在 NestJS 中：
> **流程控制装饰器 = 控制“请求什么时候能进来、数据怎么处理、结果怎么出去、出错怎么办”**

---

# 🧠 一句话先建立全局视角（非常重要）

一次请求在 NestJS 中的真实流向是：

```txt
HTTP Request
 ↓
Middleware
 ↓
Guard        （能不能进）
 ↓
Pipe         （数据对不对）
 ↓
Controller
 ↓
Service
 ↓
Interceptor  （结果怎么返回）
 ↓
Exception Filter（如果出错）
```

📌 **流程控制装饰器控制的就是中间这几层**

---

# 🧩 一、流程控制装饰器有哪些？（先给全名单）

你现在阶段 **只需要重点记住 4 个**

| 装饰器                  | 控制什么      |
| -------------------- | --------- |
| `@UseGuards()`       | 权限 / 登录   |
| `@UsePipes()`        | 参数校验 / 转换 |
| `@UseInterceptors()` | 返回结果 / 日志 |
| `@UseFilters()`      | 异常处理      |

👉 它们**都可以写在：**

* Controller 上（作用于整个控制器）
* 方法上（只作用于当前接口）

---

# 🧩 二、`@UseGuards()` —— 能不能访问？（最重要）

> **Guard 决定：这个请求“有没有资格进 Controller”**

---

## 1️⃣ Guard 的典型使用场景

* 是否登录
* 是否有权限（admin / user）
* 是否携带合法 token

---

## 2️⃣ 最基本的 Guard 示例

### `auth.guard.ts`

```ts
@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const req = context.switchToHttp().getRequest();
    return !!req.headers.authorization;
  }
}
```

### Controller 使用

```ts
@UseGuards(AuthGuard)
@Get('profile')
getProfile() {}
```

📌 **不通过会怎样？**

* 返回 `403 Forbidden`
* Controller 根本不会执行

---

## 3️⃣ Guard 写在哪里？

```txt
src/
├── auth/
│   ├── auth.guard.ts
│   └── auth.module.ts
```

📌 **原则**

> Guard 属于“安全层”，通常单独一个模块

---

# 🧩 三、`@UsePipes()` —— 数据对不对？（和 DTO 强相关）

> **Pipe 负责：校验 + 转换数据**

---

## 4️⃣ 最常用 Pipe：`ValidationPipe`

### 全局使用（推荐）

```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    transform: true,
  }),
);
```

👉 **90% 项目只需要这一种**

---

## 5️⃣ 局部使用 Pipe（了解）

```ts
@Post()
@UsePipes(new ValidationPipe())
create(@Body() dto: CreateUserDto) {}
```

📌 实际项目中：

* **全局 Pipe**
* 局部 Pipe 很少用

---

## 6️⃣ 内置 Pipe 示例

```ts
@Get(':id')
find(@Param('id', ParseIntPipe) id: number) {}
```

📌 作用：

* `'1'` → `1`
* 非数字直接 400

---

# 🧩 四、`@UseInterceptors()` —— 请求 & 响应加工厂

> **Interceptor = 请求前后都能动手**

---

## 7️⃣ Interceptor 能干什么？

* 统一返回格式
* 打日志
* 计算接口耗时
* 包装响应数据

---

## 8️⃣ 最常见：统一返回格式
<!-- TODO -->
### `response.interceptor.ts`

```ts
@Injectable()
export class ResponseInterceptor implements NestInterceptor {
  intercept(context, next) {
    return next.handle().pipe(
      map(data => ({
        code: 0,
        data,
        message: 'success',
      })),
    );
  }
}
```

### 使用

```ts
@UseInterceptors(ResponseInterceptor)
@Get()
findAll() {}
```

📌 **Controller 返回什么已经不重要了**

* Interceptor 会统一包装

---

## 9️⃣ Interceptor 写在哪里？

```txt
src/
├── common/
│   ├── interceptors/
│   │   └── response.interceptor.ts
```

---

# 🧩 五、`@UseFilters()` —— 出错怎么办？

> **Exception Filter = 兜底错误处理**

---

## 🔟 最常见场景

* DTO 校验失败
* 手动 `throw new HttpException()`
* Service 抛错

---

## 1️⃣1️⃣ 自定义异常过滤器

```ts
@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse();
    response.status(exception.getStatus()).json({
      code: -1,
      message: exception.message,
    });
  }
}
```

### 使用

```ts
@UseFilters(HttpExceptionFilter)
@Get()
findAll() {}
```

📌 实际项目：

* 多数是 **全局 Filter**
* 局部用得很少

---

# 🧩 六、这些装饰器写在哪里？（速查表）

| 装饰器                | 写在              |
| ------------------ | --------------- |
| `@UseGuards`       | Controller / 方法 |
| `@UsePipes`        | Controller / 方法 |
| `@UseInterceptors` | Controller / 方法 |
| `@UseFilters`      | Controller / 方法 |

📌 也都支持 **全局注册（main.ts）**

---

# 🧩 七、小白最容易混淆的点（必看）

---

### ❌ 1. Guard 和 Pipe 搞混

* Guard：**能不能进**
* Pipe：**数据对不对**

---

### ❌ 2. 在 Service 用 `@UseGuards`

👉 ❌ 流程控制只属于 Controller 层

---

### ❌ 3. Controller 写太多逻辑

👉 Controller 只做“转发”

---

### ❌ 4. 同时用 `@Res()` + Interceptor

👉 会破坏响应流程

---

# 🧠 八、工程级总结（你要形成这个感觉）

```txt
Controller
= 路由 + 流程控制装饰器
= 很薄的一层
```

真正的职责分离：

| 层           | 负责 |
| ----------- | -- |
| Guard       | 权限 |
| Pipe        | 数据 |
| Interceptor | 响应 |
| Filter      | 错误 |
| Service     | 业务 |

---

# 🧠 一句话终极总结（建议背）

> * **Guard：你有没有资格进来**
> * **Pipe：你给的数据对不对**
> * **Interceptor：我怎么包装结果**
> * **Filter：出错了我怎么兜底**

---

## 🚀 下一步学习建议（强烈）

你现在已经真正进入 **NestJS 中级门槛**，下一步最合理的是：

1️⃣ **JWT 登录流程（Guard + Decorator 实战）**
2️⃣ **自定义装饰器（`@CurrentUser()`）**
3️⃣ **全局 Interceptor + Filter 工程化设计**

你选一个，我直接带你写**完整实战代码**。
----------------------------------------
这是一个**非常关键、而且很多人会误解的问题**。
我直接给你**结论 + 原理 + 正确写法**，你照着用就不会踩坑。

> 场景：在 NestJS 的 **Controller 文件中**
> 同时使用
> `@UseGuards / @UsePipes / @UseInterceptors / @UseFilters`

---

# ✅ 先给你最终结论（一定要先记住）

## ✅ **装饰器的“书写顺序”不会改变执行顺序**

👇 **不管你在代码里怎么写**：

```ts
@UseInterceptors(A)
@UseGuards(B)
@UsePipes(C)
@UseFilters(D)
```

或

```ts
@UseGuards(B)
@UsePipes(C)
@UseInterceptors(A)
@UseFilters(D)
```

👉 **NestJS 的执行顺序都是固定的，不受你写的先后顺序影响**

---

# 🧠 真正的执行顺序（核心）

NestJS 对流程控制有**严格、固定的生命周期顺序**：

```txt
请求进入
 ↓
1️⃣ Guard       （@UseGuards）
 ↓
2️⃣ Pipe         (@UsePipes)
 ↓
3️⃣ Controller
 ↓
4️⃣ Service
 ↓
5️⃣ Interceptor  (response 部分)
 ↓
6️⃣ Exception Filter（如果抛异常）
```

📌 **这是 NestJS 框架层面写死的顺序**

---

# 🧩 每一个到底在“什么时候”执行？

我用一句话给你对齐👇

| 装饰器                | 什么时候执行       | 控制什么      |
| ------------------ | ------------ | --------- |
| `@UseGuards`       | **最先**       | 能不能访问     |
| `@UsePipes`        | Guard 通过后    | 数据是否合法    |
| Controller         | Pipe 通过后     | 路由转发      |
| Service            | Controller 内 | 业务逻辑      |
| `@UseInterceptors` | **前后都能执行**   | 包装请求 / 响应 |
| `@UseFilters`      | 出异常时         | 错误处理      |

---

# 🧩 Interceptor 为什么“看起来特殊”？

Interceptor 是**唯一一个“前后都能插手”的**：

```ts
intercept(context, next) {
  // 👈 Controller 前
  return next.handle().pipe(
    // 👈 Controller 后
  )
}
```

所以真实顺序其实是：

```txt
Interceptor (before)
 ↓
Guard
 ↓
Pipe
 ↓
Controller
 ↓
Service
 ↓
Interceptor (after)
```

---

# 🧩 那“书写顺序”真的一点都不重要吗？

## ❗ 对“类型”来说：不重要

## ❗ 对“同类型多个”来说：重要

---

## ✅ 情况一：**不同类型装饰器（你现在问的）**

```ts
@UseGuards(AuthGuard)
@UsePipes(ValidationPipe)
@UseInterceptors(ResponseInterceptor)
@UseFilters(HttpExceptionFilter)
```

👉 **顺序随便写，执行顺序不变**

---

## ⚠️ 情况二：**同类型多个（重点！）**

### 多个 Guard

```ts
@UseGuards(AuthGuard, RolesGuard)
```

执行顺序：

```txt
AuthGuard → RolesGuard
```

### 多个 Interceptor

```ts
@UseInterceptors(LogInterceptor, ResponseInterceptor)
```

执行顺序：

```txt
请求： Log → Response
响应： Response → Log（反向）
```

📌 **同类型装饰器：执行顺序 = 你写的顺序**

---

# 🧩 官方推荐的“可读性最佳写法”（建议你用）

虽然顺序**不影响执行**，但**强烈建议统一风格**👇

```ts
@UseGuards(AuthGuard)
@UsePipes(ValidationPipe)
@UseInterceptors(ResponseInterceptor)
@UseFilters(HttpExceptionFilter)
@Controller('users')
export class UserController {}
```

📌 原因只有一个：

> **让人一眼就能看懂这个 Controller 的“安全 → 数据 → 响应 → 错误”策略**

---

# 🧩 方法级写法（同样规则）

```ts
@UseGuards(AuthGuard)
@UseInterceptors(ResponseInterceptor)
@Get('profile')
getProfile() {}
```

👉 执行顺序依然不变

---

# ❌ 新手最容易犯的 3 个错误

### ❌ 1. 以为换顺序能让 Pipe 先于 Guard

👉 不可能（框架顺序）

### ❌ 2. 在 Service 上用这些装饰器

👉 ❌ 它们只属于 Controller 层

### ❌ 3. 同类型顺序乱写导致逻辑错乱

👉 多个 Interceptor / Guard **顺序必须有意识**

---

# 🧠 一句话终极总结（请背）

> * **不同类型的流程控制装饰器：顺序不影响执行**
> * **NestJS 的执行顺序是固定的**
> * **同类型多个：执行顺序 = 书写顺序**
> * **Interceptor 是前后包裹型**

---

## 🚀 下一步（强烈建议）

现在你已经理解“顺序规则”，下一步最有价值的是：

1️⃣ **写一个完整的 JWT Guard + RolesGuard（多 Guard 顺序）**
2️⃣ **多个 Interceptor 组合的真实执行顺序图解**
3️⃣ **全局 vs Controller vs 方法级优先级**

你选一个，我直接给你**实战代码 + 执行流程图**。
